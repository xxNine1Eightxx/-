import { readFileSync, writeFileSync, mkdirSync } from "node:fs";
import { join } from "node:path";

const ROOT = process.cwd();
const CANON_DIR = join(ROOT, "canon");
const VISIBLE_PATH = join(CANON_DIR, "glyph_canon_111.txt");
const INVISIBLE_PATH = join(CANON_DIR, "glyph_canon_111_invisible.txt");

const OUT_INLINE = join(CANON_DIR, "glyph_canon_111_inline.tsv");
const OUT_TS = join(ROOT, "src", "core", "glyph_canon.generated.ts");

/**
 * IMPORTANT:
 * - Do NOT .trim() because U+2800 (BRAILLE PATTERN BLANK) is meaningful.
 * - We only drop lines that are literally empty OR only ASCII whitespace AND do not contain U+2800.
 */
function normalizeLines(raw) {
  const lines = raw.replace(/\r/g, "").split("\n");

  const out = [];
  for (const line of lines) {
    const hasBrailleBlank = line.includes("\u2800"); // "â €"
    const asciiWhitespaceOnly = /^[\t \f\v]*$/.test(line);
    const trulyEmpty = line === "";

    if ((trulyEmpty || asciiWhitespaceOnly) && !hasBrailleBlank) continue;

    // Remove surrounding ASCII whitespace but preserve braille blank if present
    // and preserve the actual glyph itself.
    const stripped = line.replace(/^[\t \f\v ]+|[\t \f\v ]+$/g, "");
    if (stripped === "" && hasBrailleBlank) {
      out.push("\u2800");
    } else {
      out.push(stripped);
    }
  }
  return out;
}

function assertCount(name, arr, expected) {
  if (arr.length !== expected) {
    throw new Error(`${name} count mismatch: got ${arr.length}, expected ${expected}`);
  }
}

mkdirSync(CANON_DIR, { recursive: true });

const visibleRaw = readFileSync(VISIBLE_PATH, "utf8");
const invisibleRaw = readFileSync(INVISIBLE_PATH, "utf8");

const visible = normalizeLines(visibleRaw);
const invisible = normalizeLines(invisibleRaw);

assertCount("VISIBLE", visible, 111);
assertCount("INVISIBLE", invisible, 111);

// Write inline TSV: index \t visible \t invisible
let tsv = "";
for (let i = 0; i < 111; i++) {
  tsv += `${i}\t${visible[i]}\t${invisible[i]}\n`;
}
writeFileSync(OUT_INLINE, tsv, "utf8");

// Write TS module with both arrays and paired records
const esc = (s) => s.replace(/\\/g, "\\\\").replace(/`/g, "\\`");

let ts = `// AUTO-GENERATED by tools/gen_canon.mjs
// DO NOT EDIT BY HAND.
// Source of truth:
// - canon/glyph_canon_111.txt
// - canon/glyph_canon_111_invisible.txt

export const GLYPH_CANON_111_VISIBLE: readonly string[] = Object.freeze([
`;

for (const g of visible) ts += `  \`${esc(g)}\`,\n`;
ts += `] as const);

export const GLYPH_CANON_111_INVISIBLE: readonly string[] = Object.freeze([
`;
for (const g of invisible) ts += `  \`${esc(g)}\`,\n`;
ts += `] as const);

export type GlyphCanonPair = Readonly<{
  index: number;
  visible: string;
  invisible: string;
}>;

export const GLYPH_CANON_111_PAIRS: readonly GlyphCanonPair[] = Object.freeze(
  GLYPH_CANON_111_VISIBLE.map((v, i) => ({
    index: i,
    visible: v,
    invisible: GLYPH_CANON_111_INVISIBLE[i]!
  }))
);
`;

writeFileSync(OUT_TS, ts, "utf8");

console.log(`[gen_canon] OK: wrote:
- ${OUT_INLINE}
- ${OUT_TS}`);
